package gobash

import (
	"go/ast"

	"github.com/pkg/errors"
)

// Represents settings for Parser
type ParserSettings struct{}

var parserDefaultSettings = ParserSettings{}

// Transforms tokens into abstract syntax tree (AST)
type Parser struct {
	tokens       []*Token
	currentIndex int
	Settings     ParserSettings
	err          error
}

// Creates a new parser with settings
func NewParser(tokens []*Token, settings ParserSettings) *Parser {
	return &Parser{
		tokens:       tokens,
		currentIndex: 0,
		Settings:     settings,
		err:          nil,
	}
}

// Creates a new parser object with default settings
func NewParserDefault(tokens []*Token) *Parser {
	return &Parser{
		tokens:       tokens,
		currentIndex: 0,
		Settings:     parserDefaultSettings,
		err:          nil,
	}
}

func (p *Parser) error(format string, args ...any) {
	p.err = NewSyntaxError(errors.Errorf(format, args...))
}

func (p *Parser) current() *Token {
	return p.tokens[p.currentIndex]
}

func (p *Parser) consume() {
	p.currentIndex++
}

func (p *Parser) try(nonTerminal ...func() bool) bool {
	if p.err != nil {
		return false
	}

	b := p.currentIndex

	for _, t := range nonTerminal {
		if t() {
			return true
		}
	}

	p.currentIndex = b

	return false
}

func (p *Parser) tryNode(nonTerminal ...func() (ast.Node, bool)) (ast.Node, bool) {
	if p.err != nil {
		return nil, false
	}

	b := p.currentIndex

	for _, t := range nonTerminal {
		if node, ok := t(); ok {
			return node, true
		}
	}

	p.currentIndex = b

	return nil, false
}

func (p *Parser) accept(terminal ...TokenIdentifier) bool {
	if p.err != nil {
		return false
	}

	for _, t := range terminal {
		if p.current().Identifier == t {
			p.consume()
			return true
		}
	}

	return false
}

func (p *Parser) expect(identifier TokenIdentifier) bool {
	if !p.accept(identifier) {
		found := p.current().Identifier
		if p.current().Identifier == tokenIdentifierWord ||
			p.current().Identifier == tokenIdentifierAssignmentWord {
			found = TokenIdentifier(p.current().Value)
		}

		p.error("expected %s but found %s", identifier, found)
		return true
	}

	return false
}

func (p *Parser) Parse() error {
	if !p.program() {
		if p.err != nil {
			return p.err
		} else {
			p.error("syntax error: unexpected %s", p.current().Identifier)
			return p.err
		}
	}

	p.expect(tokenIdentifierEOF)
	return p.err
}

func (p *Parser) program() bool {
	if !p.try(p.linebreak) {
		return false
	}

	if p.accept(tokenIdentifierEOF) {
		return true
	}

	if p.try(p.completeCommands) {
		return p.try(p.linebreak)
	}

	return false
}

func (p *Parser) completeCommands() bool {
	if !p.completeCommand() {
		return false
	}

	for {
		if !p.try(func() bool { return p.newlineList() && p.completeCommand() }) {
			break
		}
	}

	return true
}

// list and complete_command grammer rules are ambiguous. combine them together
func (p *Parser) completeCommand() bool {

	if !p.try(p.list) {
		return false
	}

	p.try(p.separatorOp)

	return true
}

func (p *Parser) list() bool {
	if !p.try(p.andOr) {
		return false
	}

	for {
		if !p.try(func() bool { return p.separatorOp() && p.andOr() }) {
			break
		}
	}

	return true
}

func (p *Parser) andOr() bool {
	for {
		if !p.try(p.pipeline) {
			return false
		}

		if !p.accept(tokenIdentifierDAnd) && !p.accept(tokenIdentifierDPipe) {
			break
		}

		if !p.try(p.linebreak) {
			return false
		}
	}

	return true
}

func (p *Parser) pipeline() bool {
	for {
		if !p.try(p.pipelineSequence) {
			return false
		}

		if !p.accept(tokenIdentifierBang) {
			break
		}
	}

	// TODO: Fix this

	return true
}

func (p *Parser) pipelineSequence() bool {
	if !p.try(p.command) {
		return false
	}

	for {
		if !p.try(func() bool { return p.accept(tokenIdentifierPipe) && p.try() }) {
			break
		}
	}

	return true
}

func (p *Parser) command() bool {
	return p.simpleCommand()

	// TODO
}

func (p *Parser) simpleCommand() bool {
	if p.try(p.cmdPrefix) {
		if p.try(p.cmdWord) {
			p.try(p.cmdSuffix)
		}
	} else if p.try(p.cmdName) {
		p.cmdSuffix()
	} else {
		return false
	}

	return true
}

func (p *Parser) cmdPrefix() bool {
	if !p.try(p.ioRedirect) && !p.try(p.assignmentWord) {
		return false
	}

	for {
		if !p.try(p.ioRedirect) && !p.try(p.assignmentWord) {
			break
		}
	}

	return true
}

func (p *Parser) cmdWord() bool {
	p.current().tryUpgradeToAssignmentWord() // rule 7b

	return p.accept(tokenIdentifierWord)
}

func (p *Parser) cmdSuffix() bool {
	if !p.try(p.ioRedirect) && !p.accept(tokenIdentifierWord) {
		return false
	}

	for {
		if !p.try(p.ioRedirect) && !p.accept(tokenIdentifierWord) {
			break
		}
	}

	return true
}

func (p *Parser) cmdName() bool {
	return p.accept(tokenIdentifierWord)
}

func (p *Parser) ioRedirect() bool {
	if p.accept(tokenIdentifierIONumber) {
		return p.try(p.ioFile)
	} else {
		return p.try(p.ioFile)
	}
}

func (p *Parser) ioFile() bool {
	if !p.accept(tokenIdentifierLess) &&
		!p.accept(tokenIdentifierGreat) &&
		!p.accept(tokenIdentifierDGreat) &&
		!p.accept(tokenIdentifierLessAnd) &&
		!p.accept(tokenIdentifierLessGreat) &&
		!p.accept(tokenIdentifierClobber) {
		return false
	}

	return p.try(p.filename)
}

func (p *Parser) filename() bool {
	return p.accept(tokenIdentifierWord)
}

func (p *Parser) separatorOp() bool {
	return p.accept(tokenIdentifierAnd) || p.accept(tokenIdentifierSemicolon)
}

func (p *Parser) linebreak() bool {
	p.newlineList()

	return true
}

func (s *Parser) newlineList() bool {
	// read at least one newline
	if !s.accept(tokenIdentifierNewline) {
		return false
	}

	for {
		if !s.accept(tokenIdentifierNewline) {
			break
		}
	}

	return true
}

// in the grammer this is a terminal. it will be represented
// here as a non-terminal to parse context depended information
func (p *Parser) assignmentWord() bool {
	p.current().tryUpgradeToAssignmentWord() // rule 7b
	return p.accept(tokenIdentifierAssignmentWord)
}
